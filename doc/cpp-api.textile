---
layout: default
title: "C++ API Documentation"
lang: en
---

h1. C++ API Documentation

h2. Draw a sketch

<div class="float">
<pre>
#include <iostream>
#include <string>

#include <madoka.h>

int main(int argc, char *argv[]) {
  madoka::Sketch sketch;
  sketch.create();

  std::string key;
  while (std::getline(std::cin, key)) {
    sketch.inc(key.c_str(), key.length());
  }
  sketch.save(argv[1]);
  return 0;
}
</pre>
</div>

Let's try to draw a sketch! This example reads a keyset from standard input (<var>std::cin</var>) and draws a sketch (<code>madoka::Sketch</code>). Then, this example saves the sketch to a file specified by the 1st command line argument (<var><notextile>argv[1]</notextile></var>). The following are the points of this example.

* <kbd>madoka.h</kbd>
** <code>#include <madoka.h></code> is needed to use Madoka. Data types, constants and classes are defined in <kbd>madoka.h</kbd>.
* <code>madoka::Sketch</code>
** <code>madoka::Sketch</code> represents a sketch and provides functions for sketching.
* <code>madoka::Sketch::create()</code>
** <code>create()</code> is a function to make a sketch. You must not start sketching before making a sketch.
* <code>madoka::Sketch::inc()</code>
** <code>inc()</code> is a function to increment values associated with a key. The 1st argument specifies the starting address and the 2nd argument specifies the length in bytes of the key. Yeah, this is sketching.
* <code>madoka::Sketch::save()</code>
** <code>save()</code> is a function to save a sketch. The 1st argument specifies the path of the file.

<div class="float">
<pre>
$ g++ draw-a-sketch.cc -lmadoka
$ ./a.out SKETCH < KEYSET
</pre>
</div>

Note that an option <kbd>-lmadoka</kbd> is needed to build this example. If you have installed Madoka, <kbd>pkg-config madoka --libs</kbd> is available to get the required options.

h2. Look at a sketch

<div class="float">
<pre>
#include <iostream>
#include <string>

#include <madoka.h>

int main(int argc, char *argv[]) {
  madoka::Sketch sketch;
  sketch.load(argv[1]);  // or sketch.open(argv[1]);

  std::string key;
  while (std::getline(std::cin, key)) {
    std::cout << key << ": "
              << sketch.get(key.c_str(), key.length()) << std::endl;
  }
  return 0;
}
</pre>
</div>

Next, let's try to look at a sketch! This example loads a sketch from a file specified by the 1st command line argument (<var><notextile>argv[1]</notextile></var>). Then, this example looks up keys read from standard input (<var>std::cin</var>). The following are the points of this example.

* <code>madoka::Sketch::load()</code>
** <code>load()</code> is a function to load a sketch from a file. The 1st argument specifies the path of the file.
** Note that <code>open()</code> is also available to access a sketch file when you don't want to load the whole file. <code>open()</code> uses memory mapped I/O instead of reading the whole sketch into memory.
* <code>madoka::Sketch::get()</code>
** <code>get()</code> is a function to get the value associated with a key. The 1st argument specifies the starting address and the 2nd argument specifies the length in bytes of the key.

h3. Use other brushes

<div class="float">
<pre>
#include <iostream>
#include <string>

#include <madoka.h>

int main(int argc, char *argv[]) {
  madoka::Sketch sketch;
  sketch.create();

  sketch.set("QB", 2, 10);
  std::cout << "QB: "
            << sketch.add("QB", 2, 5) << std::endl;
  sketch.set("QB", 2, 7);
  std::cout << "QB: "
            << sketch.get("QB", 2) << std::endl;
  return 0;
}
</pre>
</div>

<code>madoka::Sketch</code> provides other drawing functions named <code>set()</code> and <code>add()</code>. This example shows how these functions work.

* <code>madoka::Sketch::set()</code>
** <code>set()</code> is a function to update a value associated with a key. The 1st argument specifies the starting address and the 2nd argument specifies the length in bytes of the key. The 3rd argument specifies the value.
** Note that <code>set()</code> does nothing when the specified value is not greater than the current associated value.
* <code>madoka::Sketch::add()</code>
** <code>add()</code> is a function to perform an addition. The 1st argument specifies the starting address and the 2nd argument specifies the length in bytes of the key. The 3rd argument specifies the value to be added.
** Note that <code>add()</code> returns the result of the addition.

<div class="float">
<pre>
$ g++ use-other-brushes.cc -lmadoka
$ ./a.out
QB: 15
QB: 15
</pre>
</div>

In this example, the 1st <code>set()</code> changes the value associated with <var>"QB"</var> from <var>0</var> to <var>10</var>. Then, <code>add()</code> adds <var>5</var> to that value (from <var>10</var> to <var>15</var>). After that, the 2nd <code>set()</code> does nothing because the specified value (<var>7</var>) is less than the current value (<var>15</var>).

h2. Customize a sketch

<div class="float">
<pre>
#include <iostream>
#include <string>

#include <madoka.h>

int main(int argc, char *argv[]) {
  const madoka::UInt64 MY_WIDTH = 1ULL << 24;
  const madoka::UInt64 MY_MAX_VALUE = 10;

  madoka::Sketch sketch;
  sketch.create(MY_WIDTH, MY_MAX_VALUE);

  std::cout << "Size: "
            << sketch.file_size() << std::endl;
  return 0;
}
</pre>
</div>

Let's customize a sketch for your application. A Count-Min sketch is a probabilistic data structure and the accuracy depends on its parameters, <var>width</var> and <var>depth</var>, and the target data stream.

Basically, accurate sketching requires a large <var>width</var> and a longer stream requires a larger <var>width</var>, but a larger <width> requires a larger memory space and increases cache misses. The other parameter, <var>depth</var>, also has an effect on accuracy but Madoka uses a fixed <var>depth</var>, actually <var>3</var>, based on benchmarks. Instead, Madoka has another parameter, <var>max_value</var>, that specifies the upper limit of the values. By using a small <var>max_value</var>, you can save memory.

<div class="float">
<pre>
$ g++ customize-a-sketch.cc -lmadoka
$ ./a.out
Size: 25165904
</pre>
</div>

To customize a sketch, specify <var>width</var> and <var>max_value</var> when creating a sketch. Note that the size in bytes of a sketch is approximately <var>width x depth x log<sub>2</sub>(max_value) / 8</var>.

* <var>width</var>
** <var>0</var> is replaced with the default value <var>madoka::SKETCH_DEFAULT_WIDTH</var> (<var>2<sup>20</sup></var>).
** <var>width</var> must not be greater than <var>madoka::SKETCH_MAX_WIDTH</var> (<var>2<sup>42</sup></var>).
* <var>max_value</var>
** <var>0</var> is replaced with the default value <var>madoka::SKETCH_DEFAULT_MAX_VALUE</var> (<var>2<sup>45</sup> - 1</var>).
** <var>max_value</var> must not be greater than <var>madoka::SKETCH_MAX_MAX_VALUE</var> (<var>2<sup>45</sup> - 1</var>).
** <code>create()</code> rounds out a given <var>max_value</var> to <var>1</var>, <var>3</var>, <var>15</var>, <var>255</var>, <var>65535</var> or <var>madoka::SKETCH_MAX_MAX_VALUE</var>.

h2. Get information of a sketch

h2. Share a sketch

h2. Error handling

What function may throw an exception?

h2. Namespace

<div class="float">
<pre>
namespace madoka {
// ...
}  // namespace madoka
</pre>
</div>

The C++ API of Madoka uses a namespace <code>madoka</code>. Types and constants are defined in this namespace.

h2. Types

h3. Integers

<div class="float">
<pre>
typedef uint8_t  UInt8;
typedef uint16_t UInt16;
typedef uint32_t UInt32;
typedef uint64_t UInt64;
</pre>
</div>

h3. Filter

<div class="float">
<pre>
typedef UInt64 (*SketchFilter)(UInt64);
</pre>
</div>

h3. Classes

<div class="float">
<pre>
class Sketch;
</pre>
</div>

h2. Constants

<div class="float">
<pre>
enum SketchMode {
  SKETCH_EXACT_MODE,
  SKETCH_APPROX_MODE
};

enum FileFlag {
  FILE_CREATE,
  FILE_TRUNCATE,
  FILE_READONLY,
  FILE_WRITABLE,
  FILE_SHARED,
  FILE_PRIVATE,
  FILE_ANONYMOUS,
  FILE_HUGETLB,
  FILE_PRELOAD
};
</pre>
</div>

h2. Class

<div class="float">
<pre>
class Sketch {
 public:
  typedef SketchFilter Filter;
  typedef SketchMode Mode;

  Sketch() throw();
  ~Sketch() throw();

  void create(UInt64 width = 0, UInt64 max_value = 0,
              const char *path = NULL, int flags = 0,
              UInt64 seed = 0) throw(Exception);
  void open(const char *path, int flags = 0) throw(Exception);
  void close() throw();

  void load(const char *path, int flags = 0) throw(Exception);
  void save(const char *path, int flags = 0) const throw(Exception);

  UInt64 width() const throw();
  UInt64 width_mask() const throw();
  UInt64 depth() const throw();
  UInt64 max_value() const throw();
  UInt64 value_mask() const throw();
  UInt64 value_size() const throw();
  UInt64 seed() const throw();
  UInt64 table_size() const throw();
  UInt64 file_size() const throw();
  int flags() const throw();
  Mode mode() const throw();

  UInt64 get(const void *key_addr, std::size_t key_size) const throw();
  void set(const void *key_addr, std::size_t key_size, UInt64 value) throw();
  UInt64 inc(const void *key_addr, std::size_t key_size) throw();
  UInt64 add(const void *key_addr, std::size_t key_size, UInt64 value) throw();

  void clear() throw();

  void copy(const Sketch &src, const char *path = NULL,
            int flags = 0) throw(Exception);

  void filter(Filter filter) throw();

  void shrink(const Sketch &src, UInt64 width = 0,
              UInt64 max_value = 0, Filter filter = NULL,
              const char *path = NULL, int flags = 0) throw(Exception);

  void merge(const Sketch &rhs, Filter lhs_filter = NULL,
             Filter rhs_filter = NULL) throw(Exception);

  void swap(Sketch *sketch) throw();

  double inner_product(const Sketch &rhs, double *lhs_square_length = NULL,
      double *rhs_square_length = NULL) const throw(Exception);
};
</pre>
</div>

h2. 
